*******************************************
Student name: Vinh Nhan
Student ID: 171452212
Date complete: Mar 19, 2023
Workshop 7 - Reflection
*******************************************


1. list all the STL functions that you have used in this workshop; explain your reasoning for choosing each one, and not another.
for_each(): This STL function is used in showGoods() member function of class Bakery. The purpose of showGoods() is to display all the baked goods; therefore, for_each() function can easily accomplish this task by query each element in the vector and display them using cout
for_each(m_bakedGood.begin(), m_bakedGood.end(), [&os](const BakedGood& bg) {
            os << bg << endl;
         });

accumulate(): This STL function accumulates elements from a container and is used to calculate the total of stock quantity and price of all baked goods in the vector m_bakedGood.
int totalStock = accumulate(m_bakedGood.begin(), m_bakedGood.end(), (int)0, 
                       [](int total, const BakedGood& bakedGood) {
                           return total + bakedGood.m_stockQty;
                       });

      double totalPrice = accumulate(m_bakedGood.begin(), m_bakedGood.end(), (double)0, 
                          [](double total, const BakedGood& bakedGood) {
                              return total + bakedGood.m_price;
                          });
						  
sort(): sortBakery(const char* field) member function allows users to sort baked goods by field. To accomplish this, STL sort() is used with the additional logic of determining which field to sort (by comparing the field name argument). If successful, m_bakedGood will be sorted accordingly.
 sort(m_bakedGood.begin(), m_bakedGood.end(), [field](const BakedGood& bg1, const BakedGood& bg2) {
         bool result{};
         if (!strcmp(field, "Description")) {
            result = bg1.m_desc < bg2.m_desc;
         }
         else if (!strcmp(field, "Shelf")) {
            result = bg1.m_shelfLife < bg2.m_shelfLife;
         }
         else if (!strcmp(field, "Stock")) {
            result = bg1.m_stockQty < bg2.m_stockQty;
         }
         else if (!strcmp(field, "Price")) {
            result = bg1.m_price < bg2.m_price;
         }
         else {
            throw "ERROR! INVALID FIELD NAME!";
         }
         return result;
         });
		 
merge(): Bakery class allows combining other baked goods to the current ones through combine(). To do this, STL merge() is used to combine the vector of m_bakedGood from another Bakery to the current one. The lambda expression used in merge() helps sort the two baked good vectors by price to fulfill the requirement of this workshop.
   std::vector<BakedGood> Bakery::combine(const Bakery& B) {
      this->sortBakery("Price");
      
      vector<BakedGood> combinedB(m_bakedGood.size() + B.m_bakedGood.size());
      merge(m_bakedGood.begin(), m_bakedGood.end(), 
            B.m_bakedGood.begin(), B.m_bakedGood.end(), 
            combinedB.begin(), 
            [](const BakedGood& bg1, const BakedGood& bg2) { 
                  return bg1.m_price < bg2.m_price;
            });

      return combinedB;
   }
   
any_of(): class Bakery allows users to check if a baked item of a specific type is in stock or not. This will require to loop through the baked good vector, using the item details passed as arguments to determine if it's in stock. The STL any_of() can accomplish this task of looping and returning true if any of the baked item's stock is greater than 0.
bool Bakery::inStock(const char* desc, BakedType type) const {
      return any_of(m_bakedGood.begin(), m_bakedGood.end(), 
                    [desc, type](const BakedGood& bg) {
                        return (bg.m_desc == desc && 
                                bg.bakedType == type && 
                                bg.m_stockQty > 0);
                    });
   }
   
copy_if(): member function outOfStock() allows users to check if all baked goods of a certain type are out of stock. To acquire this, the STL copy_if function is used to search for all baked items of the specified type that are out of stock (quantity = 0) and copy them to another container (of type list). The outOfStock() returns a list of out of stock items found.
 std::list<BakedGood> Bakery::outOfStock(const BakedType type) const {
      list<BakedGood>outOfStock(m_bakedGood.size());
      auto it = copy_if(m_bakedGood.begin(), m_bakedGood.end(), outOfStock.begin(),
              [type](const BakedGood& bg) {
                  return (bg.bakedType == type && !bg.m_stockQty);
              });
      outOfStock.resize(distance(outOfStock.begin(), it));
      return outOfStock;
   }


2. present the advantages of using STL algorithms vs. implementing the functionality by yourself using loops.
While most of the tasks in this workshop can be accomplished using normal loops, using STL algorithms have many benefits. Since STL algorithms are provided by the libraries, it can be easily reused throughout the program and make the code less repetitive. Moreover, these functions are created and tested so they are very efficient to use and less prone to error. Furthermore, STL functions help accomplish common tasks a lot faster without having to come up with our own solutions. Meanwhile, using normal loops requires a lot of repetitive codes (i.e., for loops with all the conditions). Not only do we have to make sure loops are correctly done, but also the logic to accomplish the task inside it.
For instance, in this workshop we need to search for a baked good that is in stock. With normal loop, we would need to take in account whether the item specified that is in stock has been found, if yes, stop looping immediately.

bool found = false;
for (auto i = 0u, i < m_bakedGood.size() && !found, i++) {  //Need to write out loop conditions, create a flag for when to stop looping, implement the logic of checking item
	found = (m_bakedGood[i].m_desc == desc && 
			 m_bakedGood[i].bakedType == type && 
			 m_bakedGood[i].m_stockQty > 0)
}

With STL algorithm:
any_of(m_bakedGood.begin(), m_bakedGood.end(), [desc, type](const BakedGood& bg) {  //only need to implement the logic of checking item as a lambda expression
                        return (bg.m_desc == desc && 
                                bg.bakedType == type && 
                                bg.m_stockQty > 0);
                    });

As a result, using STL is proven to be much more efficient and less inclined to errors.

3. for the sortBakery function, would anything differ in how it is implemented if the choice of collection was either a vector or a list? If there is a difference what is it?
